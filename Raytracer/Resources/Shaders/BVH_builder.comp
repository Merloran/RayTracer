#version 460 core
layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

struct AABB
{
	vec3 min;
	vec3 max;
}

struct BVHNode
{
    AABB boundingBox;
	// if ids are equals this is leaf
    int leftId; 
    int rightId;
}

layout(std430, binding = 0) buffer Positions
{
    vec4 positions[];
};

layout(std430, binding = 1) buffer Indexes
{
    vec4 indexes[];
};

layout(std430, binding = 2) buffer BVHBuffer 
{
    BVHNode nodes[];
};

float rand(vec2 co)
{
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

void get_triangle_bounds(int triangleId, out vec3 triangleMin, out vec3 triangleMax);
void make_aabb(int nodeId, int triangleId);
void merge_aabb(int nodeId, int leftId, int rightId);
void sort(int start, int end, int axis);

void main()
{
    uint index = gl_GlobalInvocationID.x;
    vec4 position = positions[index];
    vec4 velocity = velocities[index];
    vec2 lifetime = lifetimes[index];
	
	
	
	
}

void get_triangle_bounds(int triangleId, out vec3 triangleMin, out vec3 triangleMax)
{
	vec3 v1 = positions[indexes[triangleId + 0]];
	vec3 v2 = positions[indexes[triangleId + 1]];
	vec3 v3 = positions[indexes[triangleId + 2]];
	
	triangleMin = min(min(v1, v2), v3);
	triangleMax = max(max(v1, v2), v3);
}

void make_aabb(int nodeId, int triangleId)
{
	vec3 triangleMin, triangleMax;
	get_triangle_bounds(triangleId, triangleMin, triangleMax);
	nodes[nodeId].boundingBox.min = triangleMin;
	nodes[nodeId].boundingBox.max = triangleMax;
	nodes[nodeId].leftId = triangleId;
	nodes[nodeId].rightId = triangleId;
}

void merge_aabb(int nodeId, int leftId, int rightId)
{
	nodes[nodeId].boundingBox.min = min(nodes[leftId].boundingBox.min,
										nodes[rightId].boundingBox.min);
	nodes[nodeId].boundingBox.max = max(nodes[leftId].boundingBox.max,
										nodes[rightId].boundingBox.max);
	nodes[nodeId].leftId = leftId;
	nodes[nodeId].rightId = rightId;
}

void sort(int start, int end, int axis)
{

    int i, j, key;
    int n = data.length();

    for (i = 1; i < n; i++) {
        key = data[i];
        j = i - 1;

        /* Przesuń elementy data[0..i-1], które są większe niż key,
           na jedną pozycję do przodu od ich bieżącej pozycji */
        while (j >= 0 && data[j] > key) {
            data[j + 1] = data[j];
            j = j - 1;
        }
        data[j + 1] = key;
    }
}