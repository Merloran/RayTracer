#version 460 core
layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
#extension GL_ARB_bindless_texture : enable

#define EPSILON 0.0000001f

struct Ray
{
	vec3 origin;
	vec3 direction;
};

struct HitInfo
{
	vec3 point;
	vec3 normal;
	vec2 uv;
	float distance;
	bool frontFace;
	int materialId;
};

struct Triangle
{
	vec3 points[3];
	vec3 normals[3];
	vec2 uvs[3];
	int materialId;
};

struct Material
{
	int albedo;
	int normal;
	int roughness;
	int metalness;
	int emission;
};

layout(std430, binding = 0) readonly buffer Positions
{
    vec4 positionsWithMaterial[];
};

layout(std430, binding = 1) readonly buffer Normals
{
    vec4 normals[];
};

layout(std430, binding = 2) readonly buffer Uvs
{
    vec2 uvs[];
};

layout(std430, binding = 3) readonly buffer Indexes
{
    uint indexes[];
};

layout(std430, binding = 4) readonly buffer Textures
{
	sampler2D textures[];
};

layout(std430, binding = 5) readonly buffer Materials
{
    Material materials[];
};

layout (rgba32f, binding = 0) writeonly uniform image2D imageOutput;

uniform vec3 cameraPosition;
uniform vec3 originPixel;
uniform vec3 pixelDeltaU;
uniform vec3 pixelDeltaV;
uniform vec2 viewBounds;
uniform ivec2 imageSize;
uniform int trianglesCount;


bool triangle_intersect(int triangleId, in Ray ray, out HitInfo info);
void get_triangle(int triangleId, out Triangle triangle);

void main()
{
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    if (gid.x >= imageSize.x || gid.y >= imageSize.y)
	{
        return;
    }
	
	Ray ray;
	ray.origin = cameraPosition;
	vec3 pixelPosition = originPixel + float(gid.x) * pixelDeltaU + float(gid.y) * pixelDeltaV;
	ray.direction = normalize(pixelPosition - ray.origin);
	
    vec4 pixelColor = vec4(1.0f);
	HitInfo info, currentInfo;
	info.distance = viewBounds.y + 1.0f;
	for (int i = 0; i < trianglesCount; ++i)
	{
		if (triangle_intersect(i * 3, ray, currentInfo) && currentInfo.distance < info.distance)
		{
			info = currentInfo;
			pixelColor = texture(textures[info.materialId], info.uv);
		}
	}
	
    imageStore(imageOutput, gid, pixelColor);
}

void get_triangle(int triangleId, out Triangle triangle)
{
	uint indices[3] = 
	{
		indexes[triangleId + 0],
		indexes[triangleId + 1],
		indexes[triangleId + 2]
	};
	
	triangle.points[0] = positionsWithMaterial[indices[0]].xyz;
	triangle.points[1] = positionsWithMaterial[indices[1]].xyz;
	triangle.points[2] = positionsWithMaterial[indices[2]].xyz;
	triangle.normals[0] = normals[indices[0]].xyz;
	triangle.normals[1] = normals[indices[1]].xyz;
	triangle.normals[2] = normals[indices[2]].xyz;
	triangle.uvs[0] = uvs[indices[0]];
	triangle.uvs[1] = uvs[indices[1]];
	triangle.uvs[2] = uvs[indices[2]];
	triangle.materialId = floatBitsToInt(positionsWithMaterial[indices[0]].w);
}

bool triangle_intersect(int triangleId, in Ray ray, out HitInfo info)
{
	Triangle triangle;
	get_triangle(triangleId, triangle);
    vec3 edge1, edge2, dirXe2;
    float det;
	
    edge1 = triangle.points[1] - triangle.points[0];
    edge2 = triangle.points[2] - triangle.points[0];
	dirXe2 = cross(ray.direction, edge2);
	det = dot(edge1, dirXe2);
	
	if (det > -EPSILON && det < EPSILON)
    {
		return false;    // This ray is parallel to this triangle.
	}
	
    float invDet = 1.0f / det;
    vec3 s = ray.origin - triangle.points[0];
    float u = invDet * dot(s, dirXe2);

    if (u < 0.0f || u > 1.0f)
	{
		return false;
	}
	
    vec3 sXe1 = cross(s, edge1);
    float v = invDet * dot(ray.direction, sXe1);

    if (v < 0.0f || u + v > 1.0f)
	{
		return false;
	}
	
    // At this stage we can compute distance to find out where the intersection point is on the line.
    info.distance = invDet * dot(edge2, sXe1);

    if (info.distance < viewBounds.x || info.distance > viewBounds.y)
    {
		// This means that there is a line intersection but not a ray intersection.
		return false;
    }
	
	info.point = ray.origin + ray.direction * info.distance;
	float w = 1.0f - u - v;
	info.normal = triangle.normals[0] * w 
				+ triangle.normals[1] * u 
				+ triangle.normals[2] * v;
	info.normal = normalize(info.normal);
	
	info.uv = triangle.uvs[0] * w 
			+ triangle.uvs[1] * u 
			+ triangle.uvs[2] * v;
			
	info.materialId = triangle.materialId;
				
	return true;
}
